import { LitElement } from "lit";
import { connect } from 'pwa-helpers';
import VectorSource from "ol/source/Vector";
import Point from "ol/geom/Point";
import Feature from "ol/Feature";
import Geometry from "ol/geom/Geometry";
import Source from "ol/source/Source";
import { emitter, TIME_MILLIS_AT_ZERO } from "../utils/utils.js";
import { store } from "../redux/store.js";
import { Vehicle } from "../types/vehicle.js";

//const VehicleOpenLayersHelperMixin = (superClass: typeof LitElement) => class extends superClass {
  /* class fields & methods to extend superClass with */
//};


export class VehicleOpenLayersHelper extends connect(store)(VehicleOpenLayersHelperMixin(LitElement)) {
  private vehicles:Array<Vehicle> = [];

  private filter = false;

  private updateLock:boolean = false;

  private aircraftSource = new VectorSource({
    wrapX: false,
  });

  constructor() {
        super();
    }

    static get properties() {
        return {
          vehicles: { type: Array },
          filter: { type: String }
        };
      }

    _putVehicle(vehicle:Vehicle) {
        const feature = this.aircraftSource.getFeatureById(vehicle.id);
        if (feature) {
          const geom:Geometry | undefined= feature.getGeometry();
        //  geom.setCoordinates(vehicle.lonLat);
        } else {
          const geom = new Point(vehicle.lonLat);
          const feature = new Feature(geom);
          feature.setId(vehicle.id);
          feature.setProperties({
            vehicle
          });
          this.aircraftSource.addFeature(feature);
        }
    };

    _updateVehiclesOnMap() {
        if (!this.updateLock) {
            this.updateLock = true;
            // const stat = new Date().getTime();

            // Add all vehicles to the map that are in the vehicles list
            this.vehicles.forEach(vehicle => {
                this._putVehicle(vehicle);      
            });

            // Find all aged vehicles on the map
            const toRemove = this.aircraftSource.getFeatures().filter(feature => {
                const existingIndex = this.vehicles.findIndex(vehicle => vehicle.id === feature.getId());    
                return existingIndex===-1;
            });

            // Remove them from the map
            toRemove.forEach(feature => this.aircraftSource.removeFeature(feature));

            // const end = new Date().getTime();
            // console.log('time ' + (end-stat) + " length:"+this.__vehicles.length);
            this.updateLock = false;
        }
    }

    stateChanged(state:any) {
      this.vehicles = state.vehicles.vehicles;
      this.filter = state.filter;
    }

    vehiclesSource():Source {
        return this.aircraftSource;
    }
    
    connectedCallback() {
        super.connectedCallback()
        const that = this;
        emitter.on('vehicles.position.updated', () => {
            that._updateVehiclesOnMap();
          });
        that._updateVehiclesOnMap();
    };

}

